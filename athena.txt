//go:generate make gen_version
package main

import (
	"compress/gzip"
	"encoding/csv"
	"io"
	"os"
	"unicode/utf8"

	"strings"

	"github.com/gocql/gocql"
	logging "github.com/op/go-logging"
	"gopkg.in/alecthomas/kingpin.v2"
)

const (
	appName = "athena"
)

var (
	consistencies = []string{"ONE", "TWO", "THREE", "QUORUM", "ALL", "LOCAL_QUORUM", "LOCAL_ONE"}

	app = kingpin.New(appName, "A command-line tool to backup Cassandra keyspaces to MS Azure, by CrossEngage")

	// TODO add support for other flags, authentication, SSL, etc
	debug             = app.Flag("debug", "Enable debugging.").Short('d').Default("false").Bool()
	hostIP            = app.Flag("host", "Cassandra's host IP.").Short('h').Default("127.0.0.1").IP()
	port              = app.Flag("port", "Cassandra's host port.").Short('p').Default("9042").Int()
	protoVer          = app.Flag("protocol-version", "Prefer '3' for C* < 2.2, and '4' for C* >= 2.2, 3.x).").Default("4").Int()
	consistency       = app.Flag("consistency", "Consistency to use when querying C* ("+strings.Join(consistencies, ", ")+").").Short('C').Default("ONE").Enum(consistencies...)
	timeout           = app.Flag("timeout", "Connection timeout.").Short('t').Default("600ms").Duration()
	sockKeepAlive     = app.Flag("keep-alive", "Socket keep-alive interval.").Short('k').Default("0").Duration()
	reconnectInterval = app.Flag("reconnect-interval", "If > 0, attempt to reconnect known DOWN nodes every this").Short('R').Default("0").Duration()
	retries           = app.Flag("retries", "Number of Cassandra retries").Short('r').Default("3").Int()
	noHostLookup      = app.Flag("no-host-lookup", "If set, it will connect only to the specified node.").Short('L').Bool()
	pageSize          = app.Flag("page-size", "Page size when reading many rows.").Default("5000").Short('P').Int()
	csvSeparator      = app.Flag("separator", "CSV separator.").Short('s').Default("\t").String()
	noHeader          = app.Flag("no-header", "If set, do not add columns header to output files").Bool()
	noGzip            = app.Flag("no-gzip", "If set, do not compress the output files with gzip.").Bool()
	enableSnappy      = app.Flag("snappy", "If set, use Snappy compression with Cassandra.").Short('S').Bool()
	keyspace          = app.Arg("keyspace", "Keyspace to dump.").Required().String()
	filterTables      = app.Arg("tables", "Dump only these specified tables, otherwise will dump all tables.").Strings()

	loggr = logging.MustGetLogger(appName)
)

func init() {
	app.Version(version)
	kingpin.MustParse(app.Parse(os.Args[1:]))
	format := `%{color}%{time:15:04:05.000} %{level:-7s} ▶ %{message}%{color:reset}`

	if *debug {
		logging.SetLevel(logging.DEBUG, appName)
		format = `%{color}%{time:15:04:05.000} %{level} ¶ %{shortfile} ▶ %{message}%{color:reset}`
	} else {
		logging.SetLevel(logging.INFO, appName)
	}

	logging.SetFormatter(logging.MustStringFormatter(format))
}

func main() {
	cluster := gocql.NewCluster(hostIP.String())
	cluster.Port = *port
	cluster.Keyspace = *keyspace
	cluster.ProtoVersion = *protoVer
	cluster.Consistency = gocql.ParseConsistency(*consistency)
	cluster.Timeout = *timeout
	cluster.SocketKeepalive = *sockKeepAlive
	cluster.DisableInitialHostLookup = *noHostLookup
	cluster.PageSize = *pageSize
	cluster.ReconnectInterval = *reconnectInterval
	cluster.RetryPolicy = &gocql.SimpleRetryPolicy{NumRetries: *retries}
	if *enableSnappy {
		cluster.Compressor = gocql.SnappyCompressor{}
	}

	session := startSession(cluster)
	defer session.Close()

	metadata := getKeyspaceMetadata(*keyspace, session)

	tables := selectTablesToDump(metadata, filterTables)
	for _, table := range tables {
		writer := getFileWriter(table.Keyspace, table.Name, *noGzip)
		defer writer.Close()

		csvWriter := csv.NewWriter(writer)
		csvWriter.Comma, _ = utf8.DecodeRuneInString(*csvSeparator)
		csvWriter.UseCRLF = true

		query := "SELECT * FROM " + table.Name
		loggr.Debugf("Running query `%s`", query)
		iter := session.Query(query).Iter()
		ms := newMapScanner(iter.Columns())
		if !*noHeader {
			csvWriter.Write(ms.getHeaders())
		}

		counter := 0
		total := uint64(0)

		for iter.Scan(ms.Values...) {
			if err := csvWriter.Write(ms.getStrings()); err != nil {
				loggr.Fatalf("Error while writing to CSV: %s", err)
			}
			counter++
			if iter.WillSwitchPage() {
				loggr.Infof("Flushing %d records of %s.%s", counter, table.Keyspace, table.Name)
				flushCSVWriter(csvWriter)
				total += uint64(counter)
				counter = 0
			}
		}

		total += uint64(counter)
		flushCSVWriter(csvWriter)

		if err := iter.Close(); err != nil {
			if reqErr, ok := err.(gocql.RequestError); ok {
				loggr.Fatalf("Got error %d (%s) from Cassandra host %#v while dumping", reqErr.Code(), reqErr.Message(), iter.Host())
			}
			loggr.Fatalf("Got error from Cassandra host %#v while dumping", iter.Host())
		}

		loggr.Noticef("Dumped %d records from %s.%s", total, table.Keyspace, table.Name)
	}

	loggr.Infof("That's all folks!")
}

func flushCSVWriter(csvWriter *csv.Writer) {
	csvWriter.Flush()
	if err := csvWriter.Error(); err != nil {
		loggr.Fatalf("Error while flushing to CSV: %s", err)
	}
}

func selectTablesToDump(metadata *gocql.KeyspaceMetadata, filterTables *[]string) (tables []*gocql.TableMetadata) {
	if len(*filterTables) == 0 {
		for _, table := range metadata.Tables {
			tables = append(tables, table)
			loggr.Debugf("Table %s.%s selected to be dumped", table.Keyspace, table.Name)
		}
		return
	}
	for _, tableName := range *filterTables {
		table := metadata.Tables[tableName]
		tables = append(tables, table)
		loggr.Debugf("Table %s.%s selected to be dumped", table.Keyspace, table.Name)
	}
	return
}

func outputExtention(noGzip bool) string {
	if noGzip {
		return ".csv"
	}
	return ".csv.gz"
}

func startSession(cluster *gocql.ClusterConfig) *gocql.Session {
	loggr.Infof("Starting Cassandra session on %s:%d", strings.Join(cluster.Hosts, ", "), cluster.Port)
	session, err := cluster.CreateSession()
	if err != nil {
		loggr.Fatal(err)
	}
	return session
}

func getKeyspaceMetadata(keyspace string, session *gocql.Session) *gocql.KeyspaceMetadata {
	loggr.Infof("Reading session metadata information")
	metadata, err := session.KeyspaceMetadata(keyspace)
	if err != nil {
		loggr.Fatal(err)
	}
	return metadata
}

func getFileWriter(keyspace, table string, noGzip bool) io.WriteCloser {
	csvName := keyspace + "." + table + outputExtention(noGzip)
	loggr.Infof("Exporting %s.%s to file `%s`...", keyspace, table, csvName)
	f, err := os.Create(csvName)
	if err != nil {
		loggr.Fatal(err)
	}
	writer := io.WriteCloser(f)
	if !noGzip {
		writer, err = gzip.NewWriterLevel(f, gzip.BestCompression)
		if err != nil {
			loggr.Fatal(err)
		}
	}
	return writer
}
